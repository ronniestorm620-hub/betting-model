

<!DOCTYPE html>
<html lang="da">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>‚öΩ Pro Betting Model</title>

<style>
body{font-family:Arial;background:#f2f2f2;padding:20px}
select,input,button{width:100%;font-size:18px;margin:6px 0;padding:10px}
button{background:#1e88e5;color:white;border:none;border-radius:6px}
.result{background:white;padding:15px;border-radius:8px;margin-top:15px}
</style>
</head>

<body>

<h2>‚öΩ Auto Betting Model</h2>

Liga:
<select id="league" onchange="loadTeams()"></select>

Hjemmehold:
<select id="home"></select>

Udehold:
<select id="away"></select>

<div style="display:flex;gap:20px;margin-top:10px">
<img id="homeLogo" width="50">
<img id="awayLogo" width="50">
</div>

Bookmaker odds:
<input id="odds" type="number" step="0.01" placeholder="Odds p√• bedste spil">

<h3>üéØ Custom kombi</h3>

<select id="m1"></select>
<select id="m2"></select>
<input id="comboOdds" type="number" step="0.01" placeholder="Odds p√• kombi">

<button onclick="calcCombo()">Check kombi</button>

<div id="comboOut"></div>

<h3>üíæ Hvad vil du gemme?</h3>

<label>
<input type="radio" name="saveMode" value="auto" checked>
Robot valg
</label>

<label>
<input type="radio" name="saveMode" value="custom">
Custom kombi
</label>

<button onclick="calc()">Beregn</button>

<button onclick="saveBet()">üíæ Gem spil</button>

<button onclick="exportCSV()">üì§ Export CSV</button>

<div class="result" id="out"></div>

<h3>üìä Tracking</h3>
<table id="log" style="width:100%;background:white;border-collapse:collapse">

<th>Kamp</th>
<th>Spil</th>
<th>Odds</th>
<th>Indsats</th>
<th>Model %</th>
<th>Risiko</th>
<th>EV</th>
<th>Resultat</th>
<th>Profit</th>
<th>Slet</th>

</table>

<div id="totals" style="margin-top:10px;font-weight:bold">
Total indsats: 0 KR<br>
Total profit: 0 KR
</div>

<script>

// ===== API FOOTBALL CONFIG =====

const API_KEY = "80a4837729a9e217987087d7e115972b"; // din rigtige key
const API_URL = "https://v3.football.api-sports.io";
// ===== API CACHE SYSTEM =====

// hvor l√¶nge data gemmes (timer ‚Üí 6 anbefalet)
const CACHE_HOURS = 6;

function getCache(key){

let data = localStorage.getItem(key);
if(!data) return null;

let parsed = JSON.parse(data);

// check om cache er udl√∏bet
if(Date.now() > parsed.expire){
localStorage.removeItem(key);
return null;
}

return parsed.value;
}

function setCache(key,value){

localStorage.setItem(key, JSON.stringify({
value:value,
expire: Date.now() + CACHE_HOURS*60*60*1000
}));

}
// auto current season (EU ligaer starter sommer)
// auto current season (EU ligaer starter sommer)
const CURRENT_SEASON =
new Date().getMonth() >= 6
? new Date().getFullYear()
: new Date().getFullYear()-1;


// ===== TOP 40 LIGAER (bedste + stabile stats) =====
const TOP_LEAGUES = [

39,140,135,78,61, // top 5

40,141,79,71,62, // 2. divisioner

2,3,848, // europ√¶iske turneringer

88,94,203,144,179,180, // europa tier 2

119,120,103,104,113,114, // norden

41,42, // england lower

253,262,235,307,308, // rest of world

218,219, // japan/korea

197,200,201,207,210,172 // value ligaer

];

// ===== UI ELEMENTER =====
const league = document.getElementById("league");
const home = document.getElementById("home");
const away = document.getElementById("away");
const out = document.getElementById("out");
const m1 = document.getElementById("m1");
const m2 = document.getElementById("m2");
const comboOut = document.getElementById("comboOut");
const totals = document.getElementById("totals");

// ===== LEARNING MODE =====

const MIN_LEARNING_BETS = 25; // minimum bets f√∏r ROI bruges   // true = l√¶r men blok√©r ikke
const ROI_SOFT_LIMIT = -10;   // under -10% = warning
const ROI_HARD_LIMIT = -25;   // under -25% = st√¶rk warning
const LEARNING_MODE = true; // sl√• learning til
// ===== BANKROLL =====
let BANKROLL = Number(localStorage.getItem("bankroll")) || 3000;
const KELLY_FRACTION = 0.5; // 50% Kelly (safe)

// ================= UI =================

let lastPick = null;
async function loadLeagues(){

// ‚≠ê CACHE CHECK
let cached = getCache("leagues");

if(cached){
league.innerHTML="";
cached.forEach(l=>{
league.innerHTML += `
<option value="${l.id}">
${l.name} (${l.country})
</option>`;
});
return;
}

league.innerHTML="<option>Loader...</option>";

try{

let res = await fetch(`${API_URL}/leagues`,{
headers:{ "x-apisports-key": API_KEY }
});

let data = await res.json();

league.innerHTML="";

let leagueList = data.response
.filter(l =>
TOP_LEAGUES.includes(l.league.id) &&
l.seasons?.some(s => s.year === CURRENT_SEASON)
)
.map(l=>({
id:l.league.id,
name:l.league.name,
country:l.country.name
}));

leagueList.forEach(l=>{
league.innerHTML += `
<option value="${l.id}">
${l.name} (${l.country})
</option>`;
});

// ‚≠ê GEM I CACHE
setCache("leagues",leagueList);

}catch(e){
league.innerHTML="<option>API fejl</option>";
console.log(e);
}

}

async function loadTeams(){

// ‚≠ê CACHE CHECK
let cacheKey = "teams_"+league.value;
let cached = getCache(cacheKey);

if(cached){
home.innerHTML="";
away.innerHTML="";

cached.forEach(t=>{
home.innerHTML+=`<option value="${t.id}" data-logo="${t.logo}">${t.name}</option>`;
away.innerHTML+=`<option value="${t.id}" data-logo="${t.logo}">${t.name}</option>`;
});

showLogos();
return;
}

home.innerHTML="Loader...";
away.innerHTML="";

try{

let res = await fetch(
`${API_URL}/teams?league=${league.value}&season=${CURRENT_SEASON}`,
{
headers:{ "x-apisports-key": API_KEY }
});

let data = await res.json();

home.innerHTML="";
away.innerHTML="";

// ‚≠ê gem i cache
let teamList = data.response.map(t=>({
id:t.team.id,
name:t.team.name,
logo: t.team.logo?.replace("http://","https://")
}));

setCache(cacheKey,teamList);

teamList.forEach(t=>{
home.innerHTML+=`<option value="${t.id}" data-logo="${t.logo}">${t.name}</option>`;
away.innerHTML+=`<option value="${t.id}" data-logo="${t.logo}">${t.name}</option>`;
});

showLogos();

}catch(e){
home.innerHTML="API fejl";
console.log(e);
}

}

// ===== INJURY CHECK =====
// ===== PRO INJURY IMPACT (starter vs reserve vs star) =====
async function fetchInjuries(teamId){

try{

let res = await fetch(
`${API_URL}/injuries?team=${teamId}&league=${league.value}&season=${CURRENT_SEASON}`,
{
headers:{ "x-apisports-key": API_KEY }
});

let data = await res.json();

let impact = {
attack:1,
defense:1
};

if(!data.response || data.response.length===0)
return impact;

let startersMissing = 0;

data.response.forEach(p=>{

let pos = p.player.position;
let games = p.statistics?.games?.appearences || 0;

// ===== importance level =====

// reserve (spiller n√¶sten ikke)
let importance = 0.5;

// rotation
if(games >= 10) importance = 1;

// fast starter
if(games >= 20) importance = 1.6;

// n√∏glespiller / stjerne
if(games >= 30) importance = 2.4;

if(importance >= 1.6) startersMissing++;

// ===== position impact =====

if(pos==="Attacker")
impact.attack *= (1 - 0.05 * importance);

if(pos==="Midfielder")
impact.attack *= (1 - 0.025 * importance);

if(pos==="Defender")
impact.defense *= (1 + 0.05 * importance);

if(pos==="Goalkeeper")
impact.defense *= (1 + 0.15 * importance);

});

// ‚≠ê ekstra straf hvis mange startere mangler
if(startersMissing >= 3){
impact.attack *= 0.92;
impact.defense *= 1.08;
}

// sikkerhedsgr√¶nser
impact.attack = Math.max(0.7, impact.attack);
impact.defense = Math.min(1.5, impact.defense);

return impact;

}catch(e){
return {attack:1,defense:1};
}
}

// ===== API TEAM STATS =====
async function fetchTeamStats(teamId){

// ‚≠ê CACHE CHECK
let cacheKey = "stats_"+teamId+"_"+league.value+"_"+CURRENT_SEASON;
let cached = getCache(cacheKey);
if(cached) return cached;

try{

// hent s√¶son stats
let statsRes = await fetch(
`${API_URL}/teams/statistics?team=${teamId}&league=${league.value}&season=${CURRENT_SEASON}`,
{
headers:{ "x-apisports-key": API_KEY }
});

let statsData = await statsRes.json();
let s = statsData.response;

if(!s) return null;

// m√•l stats
let homeGoalsFor = s.goals.for.total.home || 0;
let homeGoalsAgainst = s.goals.against.total.home || 0;
let awayGoalsFor = s.goals.for.total.away || 0;
let awayGoalsAgainst = s.goals.against.total.away || 0;

let homeGames = s.fixtures.played.home || 1;
let awayGames = s.fixtures.played.away || 1;

// hent sidste 10 kampe (form)
let formRes = await fetch(
`${API_URL}/fixtures?team=${teamId}&league=${league.value}&season=${CURRENT_SEASON}&last=10`,
{
headers:{ "x-apisports-key": API_KEY }
});

let formData = await formRes.json();

let wins=0;
let played=0;

formData.response.forEach(m=>{

let isHome = m.teams.home.id == teamId;
let myGoals = isHome ? m.goals.home : m.goals.away;
let oppGoals = isHome ? m.goals.away : m.goals.home;

if(myGoals!=null && oppGoals!=null){
played++;
if(myGoals > oppGoals) wins++;
}

});

let winRate = played ? wins/played : 0.5;

// return samme format som din gamle database
let result = {

home:{
a: homeGoalsFor/homeGames,
d: homeGoalsAgainst/homeGames,
win: winRate
},

away:{
a: awayGoalsFor/awayGames,
d: awayGoalsAgainst/awayGames,
win: winRate
},

total:{
a:(homeGoalsFor+awayGoalsFor)/(homeGames+awayGames),
d:(homeGoalsAgainst+awayGoalsAgainst)/(homeGames+awayGames)
}

};

// ‚≠ê GEM I CACHE + RETURN
setCache(cacheKey,result);
return result;

}catch(e){
console.log("API stats fejl",e);
return null;
}

}

// kombi markets (beholdes)
let markets=[
"Hjemmesejr","Uafgjort","Ude sejr",
"1X","X2","12",
"BTTS",
"Over 1.5","Over 2.5","Over 3.5","Over 4.5",
"Under 2.5","Under 3.5","Under 4.5"
];

m1.innerHTML="";
m2.innerHTML="";

markets.forEach(m=>{
m1.innerHTML+=`<option>${m}</option>`;
m2.innerHTML+=`<option>${m}</option>`;
});

// ================= POISSON =================

function marketHit(name,hg,ag){

let total = hg+ag;

switch(name){

case "Hjemmesejr": return hg>ag;
case "Uafgjort": return hg===ag;
case "Ude sejr": return ag>hg;

case "1X": return hg>=ag;
case "X2": return ag>=hg;
case "12": return hg!==ag;

case "Over 1.5": return total>1;
case "Over 2.5": return total>2;
case "Over 3.5": return total>3;
case "Over 4.5": return total>4;

case "Under 2.5": return total<3;
case "Under 3.5": return total<4;
case "Under 4.5": return total<5;

case "BTTS": return hg>0 && ag>0;
}

return false;
}

function randomPoisson(lambda){
let L=Math.exp(-lambda);
let k=0,p=1;
do{
k++;
p*=Math.random();
}while(p>L);
return k-1;
}

// ===== KELLY STAKE =====
function calcKellyStake(prob, odds){

if(!odds || odds <= 1) return 0;

let edge = (prob * odds - 1) / (odds - 1);

// ingen value ‚Üí ingen bet
if(edge <= 0) return 0;

let stake = BANKROLL * edge * KELLY_FRACTION;

// sikkerheds cap
stake = Math.min(stake, BANKROLL * 0.1);

// minimum stake
if(stake < 50) return 50;

return Math.round(stake);
}


// ===== KOMBI HELPERS =====

function getLine(name){
let m = name.match(/(\d\.\d)/);
return m ? parseFloat(m[1]) : null;
}

function conflict(a,b){

const dcMarkets = ["1X","X2","12"];

// blok√©r dobbeltchance + dobbeltchance
if(dcMarkets.includes(a.name) && dcMarkets.includes(b.name))
return true;

// over vs under
if(a.name.includes("Over") && b.name.includes("Under")) return true;
if(a.name.includes("Under") && b.name.includes("Over")) return true;

// samme type totals
let aLine = getLine(a.name);
let bLine = getLine(b.name);

if(aLine && bLine){
if(a.name.includes("Under") && b.name.includes("Under")) return true;
if(a.name.includes("Over") && b.name.includes("Over")) return true;
}

// specifikke konflikter
if(a.name==="BTTS" && b.name==="Under 2.5") return true;
if(b.name==="BTTS" && a.name==="Under 2.5") return true;

if(a.name==="BTTS" && b.name==="Over 1.5") return true;
if(b.name==="BTTS" && a.name==="Over 1.5") return true;

if(a.name==="1X" && b.name==="Hjemmesejr") return true;
if(b.name==="1X" && a.name==="Hjemmesejr") return true;

if(a.name==="X2" && b.name==="Ude sejr") return true;
if(b.name==="X2" && a.name==="Ude sejr") return true;

if(a.name==="12" && ["Hjemmesejr","Ude sejr"].includes(b.name)) return true;
if(b.name==="12" && ["Hjemmesejr","Ude sejr"].includes(a.name)) return true;

return false;
}

// ================= CALC =================

// ===== SMART PRIORITY ENGINE =====

function marketBias(name){

// d√¶mp hjemmesejr dominans
if(name === "Hjemmesejr")
return 0.88;

// straf dobbeltchance
if(["1X","X2","12"].includes(name))
return 0.75;

// straf ultra-safe totals
if(name==="Under 4.5")
return 0.70;

return 1;
}

function zoneScore(p){

// fjern ultra-safe spam
if(p > 0.85) return 0;

// fjern for risky
if(p < 0.35) return 0;

// betting sweet spot
return 1 - Math.abs(p - 0.58);
}

//

function safeFormBias(homeTeam, awayTeam){

   let bias = 1;

   if(homeTeam?.home?.win)
       bias += (homeTeam.home.win - 0.5) * 0.15;

   if(awayTeam?.away?.win)
       bias -= (awayTeam.away.win - 0.5) * 0.10;

   return Math.max(0.85, Math.min(1.15, bias));
}

function calc(){

Promise.all([
fetchTeamStats(home.value),
fetchTeamStats(away.value),
fetchInjuries(home.value),
fetchInjuries(away.value)
]).then(([h,a,hi,ai])=>{

if(!h || !a){
out.innerHTML="‚ö† Manglende data fra API";
return;
}

if(home.value===away.value){
out.innerHTML="‚ö† V√¶lg to forskellige hold";
return;
}

if(!h || !a){
out.innerHTML="‚ö† Manglende data";
return;
}

if(home.value===away.value){
out.innerHTML="‚ö† V√¶lg to forskellige hold";
return;
}

let expH,expA;

// ===== hjemme/ude model =====
let useHomeAway =
h.home && h.total &&
a.away && a.total;

if(useHomeAway){

expH=((h.home.a+a.away.d)+(h.total.a+a.total.d))/4;
expA=((a.away.a+h.home.d)+(a.total.a+h.total.d))/4;

}else{

let ha=h.a??h.total?.a??1;
let hd=h.d??h.total?.d??1;
let aa=a.a??a.total?.a??1;
let ad=a.d??a.total?.d??1;

expH=(ha+ad)/2;
expA=(aa+hd)/2;
}

expH=Math.max(0.1,expH);
expA=Math.max(0.1,expA);

// ‚≠ê injury impact
expH *= hi.attack;
expA *= ai.attack;

expH *= ai.defense;
expA *= hi.defense;

// ‚≠ê form bias
let bias = safeFormBias(h,a);
expH *= bias;
expA /= bias;

// ‚≠ê stabilisering
expH=Math.max(0.2, Math.min(expH,4));
expA=Math.max(0.2, Math.min(expA,4));

// ===== Monte Carlo =====
const sims=100000;

let hw=0,d=0,aw=0;
let over15=0,over25=0,over35=0,over45=0,btts=0;
let scores={};

for(let i=0;i<sims;i++){

let hg=randomPoisson(expH);
let ag=randomPoisson(expA);

if(hg>ag) hw++;
else if(hg===ag) d++;
else aw++;

let total=hg+ag;

if(total>1) over15++;
if(total>2) over25++;
if(total>3) over35++;
if(total>4) over45++;

if(hg&&ag) btts++;

let key=hg+"-"+ag;
scores[key]=(scores[key]||0)+1;
}

hw/=sims;
d/=sims;
aw/=sims;
over15/=sims;
over25/=sims;
over35/=sims;
over45/=sims;
btts/=sims;
window.lastScores = scores;
window.lastSims = sims;

// ===== market checker til kombi =====



let under25=1-over25;
let under35=1-over35;
let under45=1-over45;

let dc1x=hw+d;
let dcx2=aw+d;
let dc12=hw+aw;

// ===== score =====
let bestScore="0-0",max=0;

for(let s in scores){
if(scores[s]>max){
max=scores[s];
bestScore=s;
}
}

let scoreProb=(max/sims*100).toFixed(1);

// ===== heatmap =====
let heatHTML="<br><b>Score heatmap:</b><br><table>";

for(let hg=0;hg<=5;hg++){
heatHTML+="<tr>";
for(let ag=0;ag<=5;ag++){

let p=(scores[hg+"-"+ag]||0)/sims;

let color="#eee";
if(p>0.08) color="#4caf50";
else if(p>0.04) color="#ffc107";
else if(p>0.02) color="#ff9800";

heatHTML+=`<td style="width:36px;height:36px;text-align:center;background:${color};border:1px solid #999;font-size:12px">
${hg}-${ag}<br>${(p*100).toFixed(0)}%</td>`;
}
heatHTML+="</tr>";
}
heatHTML+="</table>";

// ===== markets =====
let markets=[

{p:hw,name:"Hjemmesejr",type:"main"},
{p:d,name:"Uafgjort",type:"main"},
{p:aw,name:"Ude sejr",type:"main"},

{p:over15,name:"Over 1.5",type:"main"},
{p:over25,name:"Over 2.5",type:"main"},
{p:over35,name:"Over 3.5",type:"main"},
{p:over45,name:"Over 4.5",type:"main"},

{p:under25,name:"Under 2.5",type:"main"},
{p:under35,name:"Under 3.5",type:"main"},
{p:under45,name:"Under 4.5",type:"main"},

{p:btts,name:"BTTS",type:"main"},

{p:dc1x,name:"1X",type:"dc"},
{p:dcx2,name:"X2",type:"dc"},
{p:dc12,name:"12",type:"dc"}

].sort((a,b)=>b.p-a.p);

let mains = markets; // inkluder ogs√• dobbeltchance

// ===== smart filter =====

let filtered = mains.filter(m=>{

// ===== AUTO BLACKLIST =====
if(LEARNING_MODE && window.marketROI){

let roi = window.marketROI[m.name];

// hvis market historisk meget d√•rlig ‚Üí ignorer
if(roi !== undefined && roi < -30) return false;

}

// anti 12 spam
if(m.name==="12" && m.p > 0.68) return false;

// straf dobbeltchance spam
if(["1X","X2","12"].includes(m.name) && m.p > 0.75)
return false;

// h√•rd blok mod ultra-safe spil
if(m.name==="Under 4.5" && under45 < 0.98) return false;

// over filtre
if(m.name==="Over 1.5" && over15 < 0.85) return false;
if(m.name==="Over 2.5" && over25 < 0.52) return false;
if(m.name==="Over 3.5" && over35 < 0.35) return false;

// under filtre
if(m.name==="Under 2.5" && under25 < 0.55) return false;
if(m.name==="Under 3.5" && under35 < 0.65) return false;

// BTTS skal ogs√• have tempo
if(m.name==="BTTS" && (btts < 0.68 || over25 < 0.50)) return false;

// undg√• for lave sandsynligheder generelt
if(m.p < 0.28) return false;

return true;
});

if(!filtered.length) filtered=mains;

// smartere prioritering ‚Äî betting zone filter


// behold kun markets i zonen
let zoned = filtered.filter(m => zoneScore(m.p) > 0);

let best;

// hvis vi har gode zone picks ‚Üí brug dem
if(zoned.length){

zoned.sort((a,b)=>
(zoneScore(b.p)*marketBias(b.name)) -
(zoneScore(a.p)*marketBias(a.name))
);
best = zoned[0];

}else{

// fallback = h√∏jeste sandsynlighed
filtered.sort((a,b)=>
(b.p*marketBias(b.name)) -
(a.p*marketBias(a.name))
);

best = filtered[0];


}

// ===== odds / EV =====

// ===== SMART KOMBI MOTOR v3 =====

let comboText = "";

let bestSingleScore = zoneScore(best.p) + (best.p * 0.4);
let bestCombo = null;

// kun st√¶rke singles m√• kombineres
let comboPool = markets.filter(m =>

// anti 12 spam ogs√• i kombi
!(m.name==="12" && m.p > 0.65) &&

m.p >= 0.55 &&
zoneScore(m.p) > 0 &&
m.p < 0.85
);

for(let i=0;i<comboPool.length;i++){
for(let j=i+1;j<comboPool.length;j++){

let A = comboPool[i];
let B = comboPool[j];

if(conflict(A,B)) continue;

// ‚≠ê STEP 3 ‚Äî stop safe + safe kombier
if(A.p > 0.80 && B.p > 0.80) continue;

// hurtig sanity check
if(A.p * B.p < 0.25) continue;

// realistisk kombi sandsynlighed

let hits = 0;

for(let s in scores){

let [hg,ag] = s.split("-").map(Number);

if(
marketHit(A.name,hg,ag) &&
marketHit(B.name,hg,ag)
){
hits += scores[s];
}

}

let comboP = hits / sims;

let impliedOdds = 1 / comboP;

// blok√©r kedelige kombier
if(impliedOdds < 1.70) continue;

// minimum kvalitet
if(comboP < 0.40) continue;

let z = zoneScore(comboP);
if(z <= 0) continue;

let comboScore = z * Math.sqrt(impliedOdds);

if(comboScore > bestSingleScore * 1.10){

if(!bestCombo || comboScore > bestCombo.score){

bestCombo = {
name: A.name + " + " + B.name,
p: comboP,
score: comboScore
};

}

}

}
}

if(bestCombo){

comboText = `
<br><b>üî• Kombi bedre end single:</b><br>
${bestCombo.name}<br>
Sandsynlighed: ${(bestCombo.p*100).toFixed(1)}%<br>
`;

}

let odds=Number(document.getElementById("odds").value)||0;

let activePick = best;
let activeProb = best.p;

if(bestCombo){
activePick = bestCombo;
activeProb = bestCombo.p;

// ROI check ogs√• for kombi
if(LEARNING_MODE && window.marketROI){

let roi = window.marketROI[activePick.name];

if(roi !== undefined){
if(roi < ROI_SOFT_LIMIT) activeProb *= 0.95;
if(roi < ROI_HARD_LIMIT) activeProb *= 0.88;
}

}
}

let ev = (odds) ? (activeProb*odds-1) : 0;
// beregn Kelly stake til visning
let kellyStake = odds ? calcKellyStake(activeProb, odds) : 0;

// ===== LEARNING WARNING =====

let learningNote = "";

if(LEARNING_MODE && window.marketROI){

let roi = window.marketROI[activePick.name];

if(roi !== undefined){

if(roi < ROI_HARD_LIMIT)
learningNote = "üö® Learning: historisk meget d√•rlig performance";

else if(roi < ROI_SOFT_LIMIT)
learningNote = "‚ö† Learning: svag historisk ROI";

}
}

const softEdge = -0.08;

let verdict;
let color;

if(ev > 0.05){
    verdict = "üî• STRONG VALUE";
    color = "green";
}
else if(ev > 0){
    verdict = "‚úÖ VALUE";
    color = "limegreen";
}
else if(ev > softEdge){
    verdict = "üü° SOFT VALUE";
    color = "orange";
}
else{
    verdict = "‚ùå DROP";
    color = "red";
}

// ===== risiko =====

let risk="üî¥ H√∏j";

if(activeProb >= 0.52)
    risk="üü¢ Lav";
else if(activeProb >= 0.42)
    risk="üü° Medium";
else risk="üî¥ H√∏j";

window.lastRisk = risk;

// sorter efter r√¶kkef√∏lge

// ===== tabel =====

// √∏nsket r√¶kkef√∏lge
const order = [
"Hjemmesejr",
"Uafgjort",
"Ude sejr",

"1X",
"X2",
"12",

"BTTS",
"Over 1.5","Over 2.5","Over 3.5","Over 4.5",
"Under 2.5","Under 3.5","Under 4.5"
];

// sorter markets
const sortedMarkets = order
.map(name => mains.find(m => m.name === name))
.filter(Boolean);

// byg tabel
let table = `<br><b>üìä Markets</b>
<table style="width:100%;border-collapse:collapse">
<tr><th>Market</th><th>%</th><th></th></tr>`;

sortedMarkets.forEach(m=>{
table += `<tr>
<td>${m.name}</td>
<td>${(m.p*100).toFixed(1)}%</td>

<td>${m.name===activePick.name?"ü§ñ":""}</td>

</tr>`;
});

table += "</table>";

// ===== output =====

lastPick = activePick;

let homeLogo =
home.options[home.selectedIndex]?.dataset?.logo ||
"https://media.api-sports.io/football/teams/0.png";

let awayLogo =
away.options[away.selectedIndex]?.dataset?.logo ||
"https://media.api-sports.io/football/teams/0.png";

out.innerHTML=`

<div style="display:flex;align-items:center;gap:20px;margin-bottom:15px">
<img src="${homeLogo}" width="50">
<b>vs</b>
<img src="${awayLogo}" width="50">
</div>

Forventede m√•l: ${expH.toFixed(2)} ‚Äì ${expA.toFixed(2)}<br>
Score: ${bestScore} (${scoreProb}%)<br><br>

üëâ Valgt spil: <b>${activePick.name}</b><br>
Model: ${(activeProb*100).toFixed(1)}%<br>

EV: ${ev.toFixed(2)}<br>
üí∞ Kelly indsats: ${kellyStake} kr<br>
Risiko: ${risk}<br>
<span style="color:${color};font-weight:bold">${verdict}</span>
${learningNote ? "<br>"+learningNote : ""}

${table}
${comboText}
${heatHTML}

`;
});
}

const oddsInput=document.getElementById("odds");

// ===== TRACKING SYSTEM =====

function saveBet(){

let mode = document.querySelector('input[name="saveMode"]:checked').value;

let homeOpt = home.options[home.selectedIndex];
let awayOpt = away.options[away.selectedIndex];

let homeName = homeOpt.text;
let awayName = awayOpt.text;

let homeLogo = homeOpt.dataset.logo;
let awayLogo = awayOpt.dataset.logo;

let matchHTML = `
<img src="${homeLogo}" width="20">
${homeName}
vs
<img src="${awayLogo}" width="20">
${awayName}
`;
let bet;
let modelP;
let odds;
let stake;

// ===== v√¶lg hvad der gemmes =====

if(mode==="custom"){

if(!document.getElementById("comboOdds").value){
alert("Indtast kombi odds");
return;
}

let A=m1.value;
let B=m2.value;

// ===== conflict check =====

let mockA={name:A};
let mockB={name:B};

if(conflict(mockA,mockB)){
comboOut.innerHTML="‚ùå Konflikt mellem markets ‚Äî kombi er ikke mulig";
return;
}

if(!window.lastScores){
alert("Beregn kamp f√∏rst");
return;
}

let hits=0;

for(let s in window.lastScores){

let [hg,ag]=s.split("-").map(Number);

if(
marketHit(A,hg,ag) &&
marketHit(B,hg,ag)
){
hits+=window.lastScores[s];
}

}

modelP = hits/window.lastSims;
bet = A+" + "+B;
odds = parseFloat(document.getElementById("comboOdds").value)||0;
stake = calcKellyStake(modelP, odds);
if(stake === 0){
alert("Ingen value ‚Äî bet ikke gemt");
return;
}

}else{

if(!lastPick){
alert("Beregn f√∏rst!");
return;
}

bet = lastPick.name;
modelP = lastPick.p;
odds = parseFloat(oddsInput.value)||0;

// ‚≠ê KELLY STAKE HER
stake = calcKellyStake(modelP, odds);
if(stake === 0){
alert("Ingen value ‚Äî bet ikke gemt");
return;
}

}

// ===== EV / risiko =====

let ev=(odds)?(modelP*odds-1):0;

let risk="üî¥ H√∏j";

if(modelP >= 0.55)
    risk="üü¢ Lav";
else if(modelP >= 0.48)
    risk="üü° Medium";

const softEdge = -0.08;

let verdict;

if(ev > 0.05){
    verdict = "üî• STRONG VALUE";
}
else if(ev > 0){
    verdict = "‚úÖ VALUE";
}
else if(ev > softEdge){
    verdict = "üü° SOFT VALUE";
}
else{
    verdict = "‚ùå DROP";
}

// ===== tabel =====

let table=document.getElementById("log");

// dublet check (kamp + spil)
for(let i=1;i<table.rows.length;i++){
let r=table.rows[i];

let existingMatch = r.cells[0].innerText;
let existingBet = r.cells[1].innerText;

if(existingMatch === (homeName+"vs"+awayName) && existingBet === bet){
alert("Spil allerede gemt for denne kamp");
return;
}
}

let row=table.insertRow();

row.insertCell(0).innerHTML = matchHTML;
row.insertCell(1).innerText=bet;
row.insertCell(2).innerText=odds||"-";
row.insertCell(3).innerText=stake;
row.insertCell(4).innerText=(modelP*100).toFixed(1)+"%";
row.insertCell(5).innerText=risk;
row.insertCell(6).innerText=verdict;

// result
let res=row.insertCell(7);

let win=document.createElement("button");
win.innerText="Win";

let loss=document.createElement("button");
loss.innerText="Loss";

res.appendChild(win);
res.appendChild(loss);

// profit
let profit=row.insertCell(8);
profit.innerText="-";

// delete
let del=row.insertCell(9);
del.innerHTML="üóë";

win.onclick=()=>{
let p=odds*stake-stake;
BANKROLL += p;
localStorage.setItem("bankroll", BANKROLL);
profit.innerText=p.toFixed(2);
profit.style.color="green";
row.dataset.result="win";
updateTotals();
saveStorage();
};

loss.onclick=()=>{
profit.innerText=(-stake).toFixed(2);
BANKROLL -= stake;
localStorage.setItem("bankroll", BANKROLL);
profit.style.color="red";
row.dataset.result="loss";
updateTotals();
saveStorage();
};

del.onclick=()=>{
row.remove();
updateTotals();
saveStorage();
};

updateTotals();
saveStorage();
}

// ===== TOTALS =====

function updateTotals(){

let table=document.getElementById("log");

let stake=0;
let profit=0;

for(let i=1;i<table.rows.length;i++){

// kun afsluttede bets til ROI
if(!table.rows[i].dataset.result) continue;

stake+=parseFloat(table.rows[i].cells[3].innerText)||0;
profit+=parseFloat(table.rows[i].cells[8].innerText)||0;
}

let roi = stake>0 ? (profit/stake*100) : 0;

totals.innerHTML=
"Bankroll: "+BANKROLL.toFixed(2)+" KR<br>"+
"Total indsats: "+stake.toFixed(2)+" KR<br>"+
"Total profit: "+profit.toFixed(2)+" KR<br>"+
"ROI: "+roi.toFixed(1)+"%";

marketStats();
calibrationStats();
}

// ===== STORAGE =====

function saveStorage(){

let table=document.getElementById("log");
let data=[];

for(let i=1;i<table.rows.length;i++){

let r=table.rows[i];

let resultState = r.dataset.result || "";

let row=[];

for(let j=0;j<9;j++){
row.push(r.cells[j].innerHTML);
}

row.push(resultState);

data.push(row);
}

localStorage.setItem("betLog",JSON.stringify(data));
}

function loadStorage(){

let saved=localStorage.getItem("betLog");
if(!saved) return;

let data=JSON.parse(saved);
let table=document.getElementById("log");

data.forEach(d=>{

let row=table.insertRow();

for(let i=0;i<7;i++){
row.insertCell().innerHTML=d[i];
}

let res=row.insertCell(7);

let win=document.createElement("button");
win.innerText="Win";

let loss=document.createElement("button");
loss.innerText="Loss";

res.appendChild(win);
res.appendChild(loss);

let profit=row.insertCell(8);
profit.innerText=d[8];

let del=row.insertCell(9);
del.innerHTML="üóë";

let odds=parseFloat(row.cells[2].innerText)||0;
let stake=parseFloat(row.cells[3].innerText)||100;

row.dataset.result=d[9]||"";

if(row.dataset.result==="win"){
let p=odds*stake-stake;
profit.innerText=p.toFixed(2);
profit.style.color="green";
}

if(row.dataset.result==="loss"){
profit.innerText=(-stake).toFixed(2);
profit.style.color="red";
}

win.onclick=()=>{
let p=odds*stake-stake;

profit.innerText=p.toFixed(2);
profit.style.color="green";

row.dataset.result="win";

updateTotals();
saveStorage();
};

loss.onclick=()=>{
profit.innerText=(-stake).toFixed(2);
profit.style.color="red";

row.dataset.result="loss";

updateTotals();
saveStorage();
};

del.onclick=()=>{
row.remove();
updateTotals();
saveStorage();
};

});

updateTotals();
}

// ===== CSV EXPORT =====

function exportCSV(){

let table=document.getElementById("log");

if(table.rows.length<=1){
alert("Ingen data");
return;
}

let csv=[];

// ===== HEADER =====
csv.push("BETTING MODEL EXPORT");
csv.push("");

// ===== BANKROLL + TOTALS =====
csv.push("BANKROLL DATA");
csv.push("Bankroll,"+BANKROLL);

let totalText = totals.innerText.split("\n");
totalText.forEach(t=>{
if(t.trim()) csv.push(t.replace(":",","));
});

csv.push("");

// ===== BETS =====
csv.push("BETS");

for(let i=0;i<table.rows.length;i++){

let cols=table.rows[i].cells;
let row=[];

for(let j=0;j<9;j++){
row.push(cols[j].innerText);
}

csv.push(row.join(","));
}

let blob=new Blob([csv.join("\n")]);
let url=URL.createObjectURL(blob);

let a=document.createElement("a");
a.href=url;
a.download="betting_export.csv";
a.click();

URL.revokeObjectURL(url);
}

function calcCombo(){

let A=m1.value;
let B=m2.value;

// dublet check f√∏rst
if(A===B){
comboOut.innerHTML="‚ö† V√¶lg to forskellige markets";
return;
}

// conflict check
if(conflict({name:A},{name:B})){
comboOut.innerHTML="‚ùå Konflikt mellem markets ‚Äî kombi er ikke mulig";
return;
}

if(!window.lastScores){
comboOut.innerHTML="‚ö† Beregn kamp f√∏rst";
return;
}

let hits=0;

for(let s in window.lastScores){

let [hg,ag]=s.split("-").map(Number);

if(
marketHit(A,hg,ag) &&
marketHit(B,hg,ag)
){
hits+=window.lastScores[s];
}

}

let modelP = hits/window.lastSims;

let odds = parseFloat(document.getElementById("comboOdds").value)||0;

let text = `
üî• Kombi: ${A} + ${B}<br>
Model: ${(modelP*100).toFixed(1)}%<br>
`;

if(odds>0){

let bookie = 1/odds;
let edge = modelP - bookie;

const softEdge = -0.08;

let verdict;
let color;

if(edge > 0.05){
    verdict = "üî• STRONG VALUE";
    color = "green";
}
else if(edge > 0){
    verdict = "‚úÖ VALUE";
    color = "limegreen";
}
else if(edge > softEdge){
    verdict = "üü° SOFT VALUE";
    color = "orange";
}
else{
    verdict = "‚ùå DROP";
    color = "red";
}

text+=`
Odds: ${odds}<br>
Bookie krav: ${(bookie*100).toFixed(1)}%<br>
Edge: ${(edge*100).toFixed(1)}%<br>
<span style="color:${color};font-weight:bold">${verdict}</span>
`;

}

comboOut.innerHTML=text;
}

// ===== MARKET ROI STATS =====

function marketStats(){

let table=document.getElementById("log");
window.marketROI = {};
let markets={};
let html="<br><b>üìä Market performance</b><br>";

// ===== samle data =====
for(let i=1;i<table.rows.length;i++){

// skip bets uden resultat
if(!table.rows[i].dataset.result) continue;

let bet=table.rows[i].cells[1].innerText;
let stake=parseFloat(table.rows[i].cells[3].innerText)||0;
let profit=parseFloat(table.rows[i].cells[8].innerText)||0;

if(!markets[bet])
markets[bet]={stake:0,profit:0,bets:0};

markets[bet].stake+=stake;
markets[bet].profit+=profit;
markets[bet].bets++;
}

// ===== beregn ROI efter loop =====
for(let m in markets){

let roi=(markets[m].profit/markets[m].stake*100)||0;

if(markets[m].bets >= MIN_LEARNING_BETS)
window.marketROI[m] = roi;

let color="black";
if(roi>5) color="green";
else if(roi<0) color="red";

html+=`<span style="color:${color}">
${m} ‚Üí ROI ${roi.toFixed(1)}% (${markets[m].bets} bets)
</span><br>`;
}

totals.innerHTML+=html;
}

// ===== MODEL CALIBRATION =====

function calibrationStats(){

let table=document.getElementById("log");

// bins i 5% intervaller
let bins={
"0-45":{bets:0,wins:0},
"45-50":{bets:0,wins:0},
"50-55":{bets:0,wins:0},
"55-60":{bets:0,wins:0},
"60-65":{bets:0,wins:0},
"65-70":{bets:0,wins:0},
"70-75":{bets:0,wins:0},
"75+":{bets:0,wins:0}
};

for(let i=1;i<table.rows.length;i++){

let row=table.rows[i];

// skip √•bne bets
if(!row.dataset.result) continue;

let modelText=row.cells[4].innerText.replace("%","");
let modelP=parseFloat(modelText);

if(isNaN(modelP)) continue;

let result=row.dataset.result==="win";

let bin;

if(modelP<45) bin="0-45";
else if(modelP<50) bin="45-50";
else if(modelP<55) bin="50-55";
else if(modelP<60) bin="55-60";
else if(modelP<65) bin="60-65";
else if(modelP<70) bin="65-70";
else if(modelP<75) bin="70-75";
else bin="75+";

bins[bin].bets++;
if(result) bins[bin].wins++;
}

// build output
let html="<br><b>üéØ Model Calibration</b><br>";

for(let b in bins){

if(bins[b].bets===0) continue;

let winrate=(bins[b].wins/bins[b].bets*100);
let color="black";

if(winrate > parseInt(b.split("-")[0]||75)) color="green";
else color="red";

html+=`
<span style="color:${color}">
${b}% ‚Üí ${(winrate).toFixed(1)}% winrate
(${bins[b].bets} bets)
</span><br>
`;
}

totals.innerHTML+=html;
}

// init app

// ===== VIS HOLD LOGO =====

home.onchange = showLogos;
away.onchange = showLogos;

function showLogos(){

document.getElementById("homeLogo").src =
home.options[home.selectedIndex]?.dataset?.logo ||
"https://media.api-sports.io/football/teams/0.png";

document.getElementById("awayLogo").src =
away.options[away.selectedIndex]?.dataset?.logo ||
"https://media.api-sports.io/football/teams/0.png";

}

window.onload = async () => {

await loadLeagues();

if(league.options.length>0){
await loadTeams();
}

loadStorage();

updateTotals(); //

};

league.onchange = loadTeams;

</script>
</body>
</html>